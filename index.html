<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Phaser Ship - 4-Point Physics Shape & Visible Zones</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { margin: 0; background-color: #222; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
        canvas { border: 1px solid #fff; }
    </style>
</head>
<body>
    <script>
        // --- Play Scene Definition ---
        class PlayScene extends Phaser.Scene {
            constructor() {
                super("PlayScene"); // Scene key
                this.player = null;
                this.cursors = null;
                this.visualLayer = null; // Renamed layer for clarity
                this.map = null;

                // --- Touch Control Properties ---
                this.zoneRotate = null; this.zoneThrust = null; this.touchRotatePointer = null;
                this.touchRotateStartX = 0; this.touchThrustPointer = null; this.touchRotatingLeft = false;
                this.touchRotatingRight = false; this.touchThrusting = false; this.debugGraphics = null;
            }

            preload() {
                // --- Create Ship Texture Dynamically ---
                // Visual uses 4 points, offset 4
                const shipGraphics = this.add.graphics();
                const shipColor = 0xffffff; const shipThickness = 1.5;
                const shipHeight = 60; const shipWidth = shipHeight * 0.8; // 42
                const shipTexWidth = 64; const shipTexHeight = 64; const shipCenterX = shipTexWidth / 2; const shipCenterY = shipTexHeight / 2; // 32, 32
                const verticalOffset = 0;
                const noseX = shipCenterX; const noseY = shipCenterY - shipHeight / 2 - verticalOffset; // (32, -2)
                const leftWingX = shipCenterX - shipWidth / 2; const leftWingY = shipCenterY + shipHeight / 2 - verticalOffset; // (11, 58)
                const rightWingX = shipCenterX + shipWidth / 2; const rightWingY = shipCenterY + shipHeight / 2 - verticalOffset; // (53, 58)
                const tailIndentX = shipCenterX; const tailIndentY = shipCenterY + shipHeight / 4 - verticalOffset; // (32, 43)
                shipGraphics.fillStyle(shipColor, 1); shipGraphics.beginPath(); shipGraphics.moveTo(noseX, noseY); shipGraphics.lineTo(leftWingX, leftWingY); shipGraphics.lineTo(tailIndentX, tailIndentY); shipGraphics.lineTo(rightWingX, rightWingY); shipGraphics.closePath(); shipGraphics.fillPath(); shipGraphics.generateTexture("ship", shipTexWidth, shipTexHeight); shipGraphics.destroy();
                console.log("Ship texture generated (64x64 - Filled 4-Point Visual - Offset 4)");

                // --- Create Tile Texture Dynamically (32x32) ---
                const tileGraphics = this.add.graphics(); tileGraphics.fillStyle(0x00ff00, 1); tileGraphics.fillRect(0, 0, 32, 32); tileGraphics.generateTexture('collisionTile', 32, 32); tileGraphics.destroy();
                console.log("Collision tile texture generated (32x32 green square for index 1)");
            }

            create() {
                // --- Define Map Properties ---
                // (Code remains the same)
                const mapWidthInTiles = 40; const mapHeightInTiles = 32; const tileWidth = 32; const tileHeight = 32;
                const mapPixelWidth = mapWidthInTiles * tileWidth; const mapPixelHeight = mapHeightInTiles * tileHeight;

                // --- Generate Tilemap Data Programmatically ---
                // (Code remains the same)
                const tilemapData = []; const borderThickness = 2;
                for (let y = 0; y < mapHeightInTiles; y++) { const row = []; for (let x = 0; x < mapWidthInTiles; x++) { if (x < borderThickness || x >= mapWidthInTiles - borderThickness || y < borderThickness || y >= mapHeightInTiles - borderThickness) { row.push(0); } else { row.push(1); } } tilemapData.push(row); }
                const innerMapStartX = borderThickness; const innerMapEndX = mapWidthInTiles - borderThickness; const innerMapStartY = borderThickness; const innerMapEndY = mapHeightInTiles - borderThickness; let placedObstacles = 0; const maxPlacementAttempts = 100; const placeObstacle = (tileX, tileY, width = 1, height = 1) => { if (tileX < innerMapStartX || tileX + width > innerMapEndX || tileY < innerMapStartY || tileY + height > innerMapEndY) { return false; } for (let y = tileY; y < tileY + height; y++) { for (let x = tileX; x < tileX + width; x++) { if (tilemapData[y][x] !== 1) { return false; } } } for (let y = tileY; y < tileY + height; y++) { for (let x = tileX; x < tileX + width; x++) { tilemapData[y][x] = 0; } } return true; };
                placedObstacles = 0; for (let i = 0; i < maxPlacementAttempts && placedObstacles < 5; i++) { let randX = Phaser.Math.Between(innerMapStartX, innerMapEndX - 1); let randY = Phaser.Math.Between(innerMapStartY, innerMapEndY - 1); if (placeObstacle(randX, randY, 1, 1)) { placedObstacles++; } } console.log(`Placed ${placedObstacles} 1x1 obstacles.`);
                placedObstacles = 0; for (let i = 0; i < maxPlacementAttempts && placedObstacles < 5; i++) { let randX = Phaser.Math.Between(innerMapStartX, innerMapEndX - 2); let randY = Phaser.Math.Between(innerMapStartY, innerMapEndY - 1); if (placeObstacle(randX, randY, 2, 1)) { placedObstacles++; } } console.log(`Placed ${placedObstacles} 2x1 obstacles.`);
                placedObstacles = 0; for (let i = 0; i < maxPlacementAttempts && placedObstacles < 5; i++) { let randX = Phaser.Math.Between(innerMapStartX, innerMapEndX - 1); let randY = Phaser.Math.Between(innerMapStartY, innerMapEndY - 2); if (placeObstacle(randX, randY, 1, 2)) { placedObstacles++; } } console.log(`Placed ${placedObstacles} 1x2 obstacles.`);
                console.log("Tilemap data generated (0=border/obstacle, 1=inside).");

                // --- Create the Phaser Tilemap ---
                // (Code remains the same)
                this.map = this.make.tilemap({ data: tilemapData, tileWidth: tileWidth, tileHeight: tileHeight });
                const tileset = this.map.addTilesetImage('collisionTile', 'collisionTile', tileWidth, tileHeight, 0, 0);
                this.visualLayer = this.map.createLayer(0, tileset, 0, 0);
                console.log("Visual tilemap layer created.");

                // --- Convert Tilemap Layer for Matter.js ---
                // (Code remains the same)
                if (this.visualLayer) { this.visualLayer.setCollision(0); this.visualLayer.setCollision(1, false); this.matter.world.convertTilemapLayer(this.visualLayer, { label: 'terrain', collisionFilter: { category: 0x0002 } }); console.log("Tilemap layer converted for Matter physics (colliding on index 0)."); } else { console.error("Visual layer not created! Cannot convert for Matter."); }


                // --- Create Player with Matter.js ---
                const playerStartX = mapPixelWidth / 2; const playerStartY = mapPixelHeight / 2;

                // **FIX:** Define vertices relative to center (0,0) for the 4-POINT collision shape
                // matching the visual drawing (verticalOffset = 4, shipHeight = 60)
                // Nose Y: -30 - 4 = -34
                // Wing Y: 30 - 4 = 26
                // Wing X: +/- 21
                // Indent Y: 15 - 4 = 11 (relative to center Y=0)
                const shipVertices = '0 -34 -23 26 0 11 23 26'; // 4-point shape
                const Matter = Phaser.Physics.Matter.Matter;
                let parsedVerts = Matter.Vertices.fromPath(shipVertices);

                // Keep vertex re-centering REMOVED
                console.log("Using original parsed 4-point vertices (no re-centering).");

                // Create the custom Matter Body using the 4-point vertices
                // Matter will decompose this concave shape internally
                const shipBody = Matter.Bodies.fromVertices(
                    playerStartX, playerStartY,
                    parsedVerts, // Use original parsed 4-point verts
                    { // Options for the Matter Body
                        label: 'player-body',
                        frictionAir: 0.01,
                        restitution: 0.5,
                        density: 0.001,
                        collisionFilter: { category: 0x0001, mask: 0x0002 }
                    }
                    // Let Matter handle convexity detection
                );

                 // Create the sprite (uses the 4-point visual texture)
                this.player = this.matter.add.sprite(playerStartX, playerStartY, 'ship', null, { label: 'player' });

                // Assign the custom 4-point body to the sprite
                this.player.setExistingBody(shipBody);
                // Use the adjusted origin found previously by user
                this.player.setOrigin(0.5, 0.58); // Keep the origin that seemed closer

                console.log("Player sprite created with 4-point Matter body.");


                // --- Setup Collisions (Matter handles physics, listeners are optional) ---
                // (No explicit collider needed here)


                 // Add text to confirm scene is running
                this.add.text(10, 10, 'PlayScene Active - Matter.js', { fontSize: '16px', fill: '#fff' }).setScrollFactor(0);

                // --- Initialize Keyboard Input ---
                this.cursors = this.input.keyboard.createCursorKeys();
                console.log("Cursor keys initialized.");

                // --- Initialize Touch Controls ---
                this.debugGraphics = this.add.graphics().setScrollFactor(0).setDepth(5).setAlpha(0.25); // Use lower alpha
                this.setupTouchControls();
                this.scale.on('orientationchange', this.updateTouchZonesLayout, this);


                // --- Camera & World Bounds ---
                // (Code remains the same)
                this.cameras.main.setBounds(0, 0, mapPixelWidth, mapPixelHeight);
                this.matter.world.setBounds(0, 0, mapPixelWidth, mapPixelHeight);
                this.cameras.main.startFollow(this.player, true, 0.1, 0.1);
                console.log(`Camera and world bounds set to ${mapPixelWidth}x${mapPixelHeight}.`);

            } // End create()

            // --- Touch Control Setup & Layout Update ---
            updateTouchZonesLayout() {
                const cam = this.cameras.main;
                const width = cam.width;
                const height = cam.height;
                const isLandscape = this.scale.isLandscape;
                console.log(`Updating touch zones for ${isLandscape ? 'Landscape' : 'Portrait'} (${width}x${height})`);

                // Define zones
                this.zoneRotate = new Phaser.Geom.Rectangle(0, height / 2, width / 2, height / 2);
                this.zoneThrust = new Phaser.Geom.Rectangle(width / 2, height / 2, width / 2, height / 2);

                // --- Redraw Debug Zones ---
                this.debugGraphics.clear(); // Clear previous drawings
                // **FIX:** Uncommented drawing lines & adjusted style
                this.debugGraphics.lineStyle(2, 0x00ff00, 0.4); // Semi-transparent Green for rotate zone
                this.debugGraphics.strokeRectShape(this.zoneRotate);
                this.debugGraphics.lineStyle(2, 0xff0000, 0.4); // Semi-transparent Red for thrust zone
                this.debugGraphics.strokeRectShape(this.zoneThrust);
                // --- End Redraw ---
            }
            // (setupTouchControls and handlers remain the same)
            setupTouchControls() { this.updateTouchZonesLayout(); if (!this.input.listeners('pointerdown').length) { this.input.on('pointerdown', this.handlePointerDown, this); this.input.on('pointermove', this.handlePointerMove, this); this.input.on('pointerup', this.handlePointerUp, this); this.input.on('gameout', () => { if (this.touchRotatePointer) this.handlePointerUp(this.touchRotatePointer); if (this.touchThrustPointer) this.handlePointerUp(this.touchThrustPointer); }, this); console.log("Touch event listeners initialized."); } }
            handlePointerDown(pointer) { if (!this.zoneRotate || !this.zoneThrust) return; const x = pointer.x; const y = pointer.y; if (Phaser.Geom.Rectangle.Contains(this.zoneRotate, x, y)) { if (this.touchRotatePointer === null) { this.touchRotatePointer = pointer; this.touchRotateStartX = x; } } else if (Phaser.Geom.Rectangle.Contains(this.zoneThrust, x, y)) { if (this.touchThrustPointer === null) { this.touchThrustPointer = pointer; this.touchThrusting = true; } } }
            handlePointerMove(pointer) { if (this.touchRotatePointer && pointer.id === this.touchRotatePointer.id) { const deltaX = pointer.x - this.touchRotateStartX; const deadZone = 4; if (deltaX < -deadZone) { this.touchRotatingLeft = true; this.touchRotatingRight = false; } else if (deltaX > deadZone) { this.touchRotatingRight = true; this.touchRotatingLeft = false; } else { this.touchRotatingLeft = false; this.touchRotatingRight = false; } } }
            handlePointerUp(pointer) { if (this.touchRotatePointer && pointer.id === this.touchRotatePointer.id) { this.touchRotatePointer = null; this.touchRotatingLeft = false; this.touchRotatingRight = false; this.touchRotateStartX = 0; } if (this.touchThrustPointer && pointer.id === this.touchThrustPointer.id) { this.touchThrustPointer = null; this.touchThrusting = false; } }


            update(time, delta) {
                // (Update logic remains the same)
                if (!this.player || !this.cursors) return; const body = this.player.body;
                if (this.touchThrustPointer && !this.touchThrustPointer.isDown) { this.handlePointerUp(this.touchThrustPointer); } if (this.touchRotatePointer && !this.touchRotatePointer.isDown) { this.handlePointerUp(this.touchRotatePointer); } else if (this.touchRotatePointer && this.touchRotatePointer.isDown) { this.handlePointerMove(this.touchRotatePointer); }
                let shouldRotateLeft = this.cursors.left.isDown || this.touchRotatingLeft; let shouldRotateRight = this.cursors.right.isDown || this.touchRotatingRight; let shouldThrust = this.cursors.up.isDown || this.touchThrusting;
                const rotationRate = 0.04; const thrustMagnitude = 0.0004;
                const angularDamping = 0.80;
                if (shouldRotateLeft) { this.player.setAngularVelocity(-rotationRate); }
                else if (shouldRotateRight) { this.player.setAngularVelocity(rotationRate); }
                else { this.player.setAngularVelocity(this.player.body.angularVelocity * angularDamping); }
                if (shouldThrust) { const angle = this.player.rotation - Math.PI / 2; const forceX = Math.cos(angle) * thrustMagnitude; const forceY = Math.sin(angle) * thrustMagnitude; this.player.applyForce({ x: forceX, y: forceY }); }
            } // End update

            // --- Removed Old Collision Handlers ---

        } // End of PlayScene Class

        // --- Phaser Game Configuration ---
        // (Config remains the same)
        const config = { type: Phaser.AUTO, width: 800, height: 600, scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH }, physics: { default: 'matter', matter: { gravity: { y: 0.16 }, debug: true, debugBodyColor: 0xffffff } }, scene: PlayScene, backgroundColor: '#222222' };

        // --- Create Phaser Game Instance ---
        const game = new Phaser.Game(config);

    </script>
</body>
</html>
